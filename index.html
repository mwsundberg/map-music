<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Map Music</title>
	<link rel="stylesheet" type="text/css" href="styles.css">
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css"
	integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
	crossorigin=""/>
	<script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js"
	integrity="sha512-GffPMF3RvMeYyc1LWMHtK8EbPv0iNZ8/oTtHPx9/cc2ILxQ+u905qIwdpULaqDkyBKgOaB57QTMg7ztg8Jm2Og=="
	crossorigin=""></script>
	<script src="leaflet-tilelayer-colorpicker.js"></script>


</head>
	<body>
		<div id="mapDrawingUIContainer">
			<canvas id="drawing"></canvas>
			<div id="map" style="height: 100vh; width: 100vw;"></div>
		</div>

		<script>
			// Map settings
			const startCenter = [43.12861, -77.630081];
			const urlTerrain = "https://api.mapbox.com/styles/v1/mwsundberg/ck26wfu0759jk1claf7a3bblm/tiles/{z}/{x}/{y}?access_token={accessToken}";
			const urlRGBheight = "https://api.mapbox.com/v4/mapbox.terrain-rgb/{z}/{x}/{y}.pngraw?access_token={accessToken}";
			const accessToken = "pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw";

			// Map initialization
			let mymap = L.map("map").setView(startCenter, 16);
			
			// Mapbox map layers
			let terrainVisible = L.tileLayer(urlTerrain, {
				attribution: "",
				minZoom: 0,
				maxZoom: 18,
				accessToken: accessToken
			}).addTo(mymap);

			let elevationData = L.tileLayer.colorPicker(urlRGBheight, {
				attribution: "",
				minZoom: 0,
				maxZoom: 18,
				maxNativeZoom: 14,
				opacity: 0.0,
				accessToken: accessToken
			}).addTo(mymap);


      //mymap.dragging.disable(); //disable drag for now

      // Data for the paths
      pathsAsCoordinates = [];
      pathsAsPolylines = []
      pathsAsElevations = [];

			let canvasSelected = document.getElementById("drawing");
			let context = canvasSelected.getContext("2d");

			// Update canvas coordinate system
			canvasSelected.width = window.innerWidth;
			canvasSelected.height = window.innerHeight;
			window.onresize = function(e){
				canvasSelected.width = window.innerWidth;
				canvasSelected.height = window.innerHeight;
			};

			// Drawing code
			const draftingLineColor = "#737561";
			const setLineColor = "#464738";
			let painting = false;
			let lineCoordinates = [];
			const distanceThreshold = 5;

			canvasSelected.onmousedown = function(e) {
				console.log("hi");
				painting = true;
				const mouseLocation = L.point(e.pageX - this.offsetLeft,
				                              e.pageY - this.offsetTop);
				
				lineCoordinates.push(mouseLocation);
				
				// Start drawing a line
				context.strokeStyle = draftingLineColor;
				context.lineJoin = "round";
				context.lineCap = "round";
				context.lineWidth = 1;
				context.beginPath();
				context.moveTo(mouseLocation.x, mouseLocation.y);
			};

			canvasSelected.onmousemove = function(e) {
				if(painting) {
					const mouseLocation = L.point(e.pageX - this.offsetLeft,
					                              e.pageY - this.offsetTop);

					// If greater than the distance criteria, draw set length lines towards current mouse location until too close
					while(mouseLocation.distanceTo(lineCoordinates[lineCoordinates.length - 1]) >= distanceThreshold){
						const lastPoint = lineCoordinates[lineCoordinates.length - 1];

						// Interpolate a point distanceThreshold units away from the last point (using: https://math.stackexchange.com/a/175906)
						const v = mouseLocation.subtract(lastPoint);
						const du = v.divideBy(v.distanceTo(L.point(0,0))).multiplyBy(distanceThreshold);
						const interpolatedPoint = du.add(lastPoint);
						
						// Add the interpolated point to the list
						lineCoordinates.push(interpolatedPoint);
						
						// Draw the next line segment
						context.lineTo(interpolatedPoint.x, interpolatedPoint.y);
						context.stroke();
					}
				}
			};

			canvasSelected.onmouseup = function(e) {
				// Convert to a GeoJSON object (Assumes canvas origin and map origin are equivalent)
				const coordinates = lineCoordinates.map((point) => {
					return mymap.containerPointToLatLng(point);
				});

				// Add GeoJSON to the map (and store the path in the polylines list)
				pathsAsPolylines.push(L.polyline(coordinates, {color: setLineColor}).addTo(mymap));

				// Points to elevation data
				const elevations = coordinates.map((point) => {
					const color = elevationData.getColor(point);
					if(color !== null){
						// Convert the RGB channels to one hex number then scale to mapbox elevation data
						return -10000 + 0.1 * ((color[0] << 16) + (color[1] << 8) + color[2]);
					} else {
						console.log("crap, coordinates at " + point + " aren't color-readable.");
					}
				});

				// Add elevation data and path to arrays
				pathsAsElevations.push(elevations);
				pathsAsCoordinates.push(coordinates);

				// Reset canvas painting stuff
				context.closePath();
				context.clearRect(0, 0, context.canvas.width, context.canvas.height); // Clears the canvas
				painting = false;
				lineCoordinates = [];
			};

		</script>
	</body>
</html>